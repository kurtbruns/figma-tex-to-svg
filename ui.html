<style>
  :root {
    --background-color: #ffffff;
    --font-color: #404040;
    --settings-panel-background: #f5f5f5;
    --settings-panel-border: #ddd;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: #38464f;
      --font-color: #e0e0e0;
      --settings-panel-background: #2a333a;
      --settings-panel-border: #555;
    }
  }

  html {
    background: var(--background-color);
  }

  h1 {
  font-size: 18px;
}

  h1,
  h2,
  h3,
  h4,
  h5,
  label,
  p {
    color: var(--font-color);
  }

  main {
    display: grid;
    grid-template-rows: auto 1fr auto;
  }

  .container {
    display: flex;
    flex-direction: column;
  }

  textarea {
    background: var(--background-color);
    color: var(--font-color);
    resize: vertical;
  }

  #display {
    text-align: end;
  }

  .controls {
    display: grid;
    grid-template-columns: auto auto;
  }

  #input {
    height: 120px;
    min-height: 120px;
  }

  #output {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    min-height: 72px;
    margin-bottom: 1rem;
    overflow: auto;
  }

  #output svg {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
  }

  #settings-panel .settings-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem 1.5rem;
    align-items: center;
  }

  #settings-panel .settings-grid > div {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  #settings-panel {
    border: 1px solid var(--settings-panel-border);
    padding: 1rem;
    margin-bottom: 0.5rem;
    border-radius: 6px;
    background: var(--settings-panel-background);
  }

  #settings-panel input {
    font-family: monospace;
  }

  #settings-panel label[for="bgcolor"],
  #settings-panel label[for="fontcolor"] {
    width: 80px;
  }

  #settings-panel input[type="color"] {
    width: 24px;
    height: 27px;
    padding: 0;
    border: none;
    background: none;
  }

  #settings-panel #bgcolor,
  #settings-panel #fontcolor {
    width: 80px;
    margin-left: 0.5rem;
  }

  #settings-panel #fontsize {
    width: 60px;
  }

  /* Sub-expression styling section */
  #subexpression-styling {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--settings-panel-border);
  }

  #subexpression-styling h3 {
    margin: 0 0 0.75rem 0;
    font-size: 14px;
    font-weight: 600;
    color: var(--font-color);
  }

  .subexpression-row {
    display: flex;
    flex-direction: row;
    gap: 0.5rem;
    align-items: center;
  }

  .subexpression-row > div {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    min-height: 30px;
    justify-content: center;
  }

  .subexpression-row > div:nth-child(2) {
    flex-direction: row;
    align-items: center;
    gap: 0.5rem;
  }

  .subexpression-row input[type="text"] {
    width: 100%;
    padding: 0.25rem;
    font-family: monospace;
    font-size: 12px;
    background: var(--background-color);
    color: var(--font-color);
    border: 1px solid var(--settings-panel-border);
    border-radius: 3px;
  }

  .subexpression-row input[type="color"] {
    width: 30px;
    height: 30px;
    padding: 0;
    border: 1px solid var(--settings-panel-border);
    border-radius: 3px;
    cursor: pointer;
  }

  .subexpression-row label {
    font-size: 11px;
    color: var(--font-color);
    opacity: 0.8;
  }

  .subexpression-row .error-message {
    color: #ff4444;
    font-size: 11px;
    margin-top: 0.25rem;
  }

  .subexpression-row button {
    background: none;
    border: 1px solid var(--settings-panel-border);
    color: var(--font-color);
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    align-self: center;
  }

  .subexpression-row button:hover {
    background: var(--settings-panel-background);
  }

  #add-subexpression-btn {
    background: var(--settings-panel-background);
    border: 1px solid var(--settings-panel-border);
    color: var(--font-color);
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    margin-top: 0.5rem;
  }

  #add-subexpression-btn:hover {
    background: var(--background-color);
  }

  /* Edit mode indicator */
  #edit-mode-indicator {
    display: none;
    padding: 0.5rem 1rem;
    margin-bottom: 0.5rem;
    border-radius: 6px;
    background: var(--settings-panel-background);
    border: 1px solid var(--settings-panel-border);
    font-size: 13px;
    color: var(--font-color);
  }

  #edit-mode-indicator.visible {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  #edit-mode-indicator .node-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  #edit-mode-indicator .node-id {
    font-family: monospace;
    font-size: 12px;
    opacity: 0.8;
  }

  #edit-mode-indicator .locate-button {
    background: none;
    border: 1px solid var(--settings-panel-border);
    color: var(--font-color);
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background-color 0.2s;
  }

  #edit-mode-indicator .locate-button:hover {
    background: var(--settings-panel-background);
  }

  /* Preview container - hidden in edit mode */
  #preview-container {
    display: block;
  }

  #preview-container.hidden {
    display: none;
  }

  /* Preview header */
  #preview-header {
    padding: 0.25rem 0;
    margin-bottom: 0.5rem;
  }

  /* Preview output container */
  #preview-output {
    overflow: auto;
  }

  /* Insert button states */
  #place {
    transition: opacity 0.2s;
  }

  #place.hidden {
    display: none;
  }
</style>

<main>
  <h1>TeX to SVG</h1>
  <div class="container">
    <textarea id="input">x=\frac{-b \pm \sqrt{b^2-4 a c}}{2 a}</textarea>
    <br>
    <div id="settings-panel">
      <div class="settings-grid">
        <div>
          <input type="checkbox" id="display" checked="true" onchange="convert();">
          <label for="display">Display style</label>
        </div>
        <div>
          <label for="bgcolor">Background</label>
          <input type="color" id="bgcolor-picker">
          <input type="text" id="bgcolor" maxlength="6" placeholder="000000" onchange="onColorTextChange('bgcolor')">
        </div>
        <div>
          <label for="fontsize">Font size</label>
          <input type="number" id="fontsize" min="8" max="1000" step="1" placeholder="12" onchange="saveConfig(); convert();">
        </div>
        <div>
          <label for="fontcolor">Font</label>
          <input type="color" id="fontcolor-picker">
          <input type="text" id="fontcolor" maxlength="6" placeholder="E0E0E0" onchange="onColorTextChange('fontcolor')">
        </div>
      </div>
      <div id="subexpression-styling">
        <div id="subexpression-rows"></div>
        <button id="add-subexpression-btn" onclick="addSubExpressionRow()">Add sub-expression style</button>
      </div>
    </div>
    <br clear="all">
    <div id="edit-mode-indicator" class="">
      <div class="node-info">
        <span>Editing node</span>
        <span class="node-id" id="node-id-display">#</span>
      </div>
      <button class="locate-button" id="locate-button">Locate in Figma</button>
    </div>
    <div id="preview-container">
      <div id="preview-header">
        <label>Preview</label>
      </div>
      <div id="preview-output">
        <div id="output"></div>
      </div>
    </div>
  </div>
  <button id="place">Embed</button>
</main>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script>
  // Frontend color normalization
  // Handles all color expansion logic before sending to backend
  // Backend expects normalized 6-digit hex colors
  // Expand color according to convention:
  // 1 digit -> repeat 6 times (2 -> 222222)
  // 2 digits -> repeat 3 times (20 -> 202020)
  // 3 digits -> duplicate each digit (123 -> 112233)
  function expandColor(hex) {
    if (!hex) return '';
    // Remove # if present and convert to uppercase
    const cleaned = hex.replace(/^#/, '').toUpperCase();
    if (cleaned.length === 1) {
      // 1 digit -> repeat 6 times
      return cleaned.repeat(6);
    } else if (cleaned.length === 2) {
      // 2 digits -> repeat 3 times
      return cleaned.repeat(3);
    } else if (cleaned.length === 3) {
      // 3 digits -> duplicate each digit
      return cleaned.split('').map(c => c + c).join('');
    }
    // 4+ digits -> return as is (should be 6 for RGB)
    return cleaned;
  }


  // Theme defaults in one place (without # prefix)
  const THEME_DEFAULTS = {
    window: {
      background: '38464F',
      font: 'E0E0E0',
    },
    dark: {
      background: '000000',
      font: 'E0E0E0',
    },
    light: {
      background: 'FFFFFF',
      font: '222222',
    },
  };

  let currentTheme = 'dark'; // fallback

  // Sub-expression styling state
  let subExpressionStyles = [];
  let subExpressionRowCounter = 0;

  function applyTheme(theme) {
    const defaults = THEME_DEFAULTS[theme] || THEME_DEFAULTS.dark;
    document.getElementById('bgcolor').value = defaults.background;
    document.getElementById('fontcolor').value = defaults.font;
    // Update color pickers to match (color inputs need # prefix)
    document.getElementById('bgcolor-picker').value = '#' + defaults.background;
    document.getElementById('fontcolor-picker').value = '#' + defaults.font;
    currentTheme = theme;
  }

  function saveConfig() {
    const display = document.getElementById("display").checked;
    const bgcolorRaw = document.getElementById("bgcolor").value.trim() || THEME_DEFAULTS[currentTheme].background;
    const fontcolorRaw = document.getElementById("fontcolor").value.trim() || THEME_DEFAULTS[currentTheme].font;
    // Expand colors (text inputs never have # prefix)
    const bgcolor = expandColor(bgcolorRaw);
    const fontcolor = expandColor(fontcolorRaw);
    const fontsizeInput = document.getElementById('fontsize').value;
    const fontsize = fontsizeInput ? parseFloat(fontsizeInput) : 24;
    
    // Collect sub-expression styles
    const styles = [];
    document.querySelectorAll('.subexpression-row').forEach((row, index) => {
      const texInput = row.querySelector('.subexpression-tex');
      const colorInput = row.querySelector('.subexpression-color');
      const occurrenceInput = row.querySelector('.subexpression-occurrence');
      if (texInput && colorInput && occurrenceInput) {
        styles.push({
          tex: texInput.value.trim(),
          color: colorInput.value.trim(),
          occurrence: occurrenceInput.value.trim()
        });
      }
    });
    
    parent.postMessage({ 
      pluginMessage: { 
        type: 'saveConfig',
        display,
        bgcolor,
        fontcolor,
        fontsize,
        subExpressionStyles: styles
      } 
    }, '*');
  }

  // Helper function to set color on all SVG elements
  function setSVGColor(svgElement, color) {
    // Set color on the root SVG element
    svgElement.setAttribute('color', color);
    
    // Traverse all elements and set fill style
    const allElements = svgElement.querySelectorAll('*');
    allElements.forEach(el => {
      // Only set fill on elements that have a fill attribute or are path/text elements
      if (el.hasAttribute('fill') || el.tagName === 'path' || el.tagName === 'text' || el.tagName === 'tspan') {
        el.style.fill = color;
      }
    });
  }

  // Sub-expression matching logic (similar to Tex.ts)
  function findSubtreeMatches(root, subtree) {
    const matches = [];

    function nodeMatches(node, subtreeNode) {
      if (node.tagName !== subtreeNode.tagName) {
        return false;
      }
      if (node.getAttribute('data-mml-node') !== subtreeNode.getAttribute('data-mml-node')) {
        return false;
      }
      if (node.hasAttribute('data-c') && node.getAttribute('data-c') !== subtreeNode.getAttribute('data-c')) {
        return false;
      }

      const nodeChildren = Array.from(node.children);
      const subtreeChildren = Array.from(subtreeNode.children);

      if (nodeChildren.length !== subtreeChildren.length) {
        return false;
      }

      for (let i = 0; i < nodeChildren.length; i++) {
        if (!nodeMatches(nodeChildren[i], subtreeChildren[i])) {
          return false;
        }
      }

      return true;
    }

    function traverse(node) {
      Array.from(node.children).forEach((child, index, children) => {
        // Check if the child node is a deep match
        if (nodeMatches(child, subtree)) {
          matches.push([child]);
        }

        // Check to see if there is a sequential match
        let currentChild = child;
        let currentNode = subtree.firstChild;
        let potentialMatch = [];
        let lastMatch = null;
        while (currentNode && currentChild && nodeMatches(currentChild, currentNode)) {
          potentialMatch.push(currentChild);
          lastMatch = currentNode;
          currentChild = currentChild.nextElementSibling;
          currentNode = currentNode.nextElementSibling;
        }

        // If the sequence matched all of the subtrees nodes then its a match
        if (lastMatch === subtree.lastChild) {
          matches.push(potentialMatch);
        }
      });

      Array.from(node.children).forEach(child => {
        traverse(child);
      });
    }

    traverse(root);
    return matches;
  }

  // Helper function to compare document position of two nodes
  function compareNodePosition(nodeA, nodeB) {
    if (!nodeA || !nodeB) return 0;
    
    // Use compareDocumentPosition for reliable ordering
    const comparison = nodeA.compareDocumentPosition(nodeB);
    
    // If nodeA comes before nodeB, return -1
    if (comparison & Node.DOCUMENT_POSITION_FOLLOWING) {
      return -1;
    }
    // If nodeA comes after nodeB, return 1
    if (comparison & Node.DOCUMENT_POSITION_PRECEDING) {
      return 1;
    }
    
    // Fallback to bounding box comparison if nodes are in different documents
    const bboxA = nodeA.getBoundingClientRect();
    const bboxB = nodeB.getBoundingClientRect();
    // First sort by y (top to bottom), then by x (left to right)
    if (Math.abs(bboxA.top - bboxB.top) > 1) { // Allow 1px tolerance for "same line"
      return bboxA.top - bboxB.top;
    }
    return bboxA.left - bboxB.left;
  }

  // Sort matches by document position (left-to-right, top-to-bottom)
  function sortMatchesByPosition(matches) {
    return matches.sort((a, b) => {
      if (a.length === 0 || b.length === 0) {
        return a.length - b.length;
      }
      // Compare the first node of each match
      return compareNodePosition(a[0], b[0]);
    });
  }

  function getMatchesByTex(tex, svgElement) {
    try {
      // Render the sub-expression
      const output = MathJax.tex2svg(tex, {});
      const matchRendered = output.firstChild;

      // Find the math nodes
      const tree = svgElement.querySelector('[data-mml-node="math"]');
      const match = matchRendered.querySelector('[data-mml-node="math"]');

      if (!tree || !match) {
        return null;
      }

      const matches = findSubtreeMatches(tree, match);
      // Sort matches by document position to ensure correct order
      return sortMatchesByPosition(matches);
    } catch (err) {
      console.error('Error matching sub-expression:', err);
      return null;
    }
  }

  function applySubExpressionColors(svgElement, styles) {
    // Clear previous validation errors
    clearSubExpressionErrors();

    if (!styles || styles.length === 0) {
      return;
    }

    styles.forEach((style, styleIndex) => {
      const { tex, color, occurrence } = style;
      
      if (!tex || !tex.trim()) {
        return; // Skip empty sub-expressions
      }

      // Find matches
      const matches = getMatchesByTex(tex.trim(), svgElement);
      
      if (!matches || matches.length === 0) {
        // Show error: sub-expression not found
        showSubExpressionError(styleIndex, 'tex', `Sub-expression '${tex}' not found in the TeX`);
        return;
      }

      // Normalize color
      const normalizedColor = '#' + expandColor(color || '000000');

      // Handle occurrence
      const occurrenceStr = (occurrence || '').trim();
      
      if (occurrenceStr === '') {
        // Apply to all matches
        matches.forEach(matchedNodes => {
          matchedNodes.forEach(node => {
            if (node.style) {
              node.style.fill = normalizedColor;
            }
          });
        });
        clearSubExpressionError(styleIndex, 'tex');
        clearSubExpressionError(styleIndex, 'occurrence');
      } else {
        // Parse comma-separated integers (1-based indexing)
        const occurrenceIndices = occurrenceStr.split(',').map(s => s.trim()).filter(s => s !== '');
        const parsedIndices = [];
        let hasError = false;
        
        for (const idxStr of occurrenceIndices) {
          const idx = parseInt(idxStr, 10);
          if (isNaN(idx)) {
            showSubExpressionError(styleIndex, 'occurrence', `Invalid occurrence number: '${idxStr}'`);
            hasError = true;
            break;
          }
          // Convert from 1-based to 0-based for array access
          const arrayIndex = idx - 1;
          if (idx < 1 || arrayIndex >= matches.length) {
            const range = matches.length > 0 ? `1-${matches.length}` : 'none';
            showSubExpressionError(styleIndex, 'occurrence', `Occurrence ${idx} is out of range. Found ${matches.length} instance(s) (valid range: ${range})`);
            hasError = true;
            break;
          }
          parsedIndices.push(arrayIndex);
        }

        if (!hasError) {
          // Apply to specific occurrences (using 0-based array indices)
          parsedIndices.forEach(arrayIndex => {
            if (matches[arrayIndex]) {
              matches[arrayIndex].forEach(node => {
                if (node.style) {
                  node.style.fill = normalizedColor;
                }
              });
            }
          });
          clearSubExpressionError(styleIndex, 'tex');
          clearSubExpressionError(styleIndex, 'occurrence');
        }
      }
    });
  }

  function showSubExpressionError(rowIndex, field, message) {
    const row = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (row) {
      const errorDiv = row.querySelector(`.error-${field}`);
      if (errorDiv) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
      }
    }
  }

  function clearSubExpressionError(rowIndex, field) {
    const row = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (row) {
      const errorDiv = row.querySelector(`.error-${field}`);
      if (errorDiv) {
        errorDiv.textContent = '';
        errorDiv.style.display = 'none';
      }
    }
  }

  function clearSubExpressionErrors() {
    document.querySelectorAll('.error-message').forEach(el => {
      el.textContent = '';
      el.style.display = 'none';
    });
  }

  // Sub-expression row management
  function addSubExpressionRow(style = null) {
    const rowIndex = subExpressionRowCounter++;
    const rowsContainer = document.getElementById('subexpression-rows');
    
    const row = document.createElement('div');
    row.className = 'subexpression-row';
    row.setAttribute('data-row-index', rowIndex);

    const texValue = style ? style.tex : '';
    const colorValue = style ? style.color : '5DA6F7';
    const occurrenceValue = style ? style.occurrence : '';

    row.innerHTML = `
      <div>
        <input type="text" class="subexpression-tex" placeholder="exp" value="${texValue}" 
               onchange="updateSubExpressionStyle(${rowIndex})" 
               oninput="updateSubExpressionStyle(${rowIndex}); convert();">
        <div class="error-message error-tex" style="display: none;"></div>
      </div>
      <div>
        <input type="color" class="subexpression-color-picker" value="#${expandColor(colorValue)}" 
               onchange="onSubExpressionColorChange(${rowIndex})">
        <input type="text" class="subexpression-color" maxlength="6" placeholder="808080" value="${colorValue}" 
               onchange="onSubExpressionColorTextChange(${rowIndex})" 
               oninput="onSubExpressionColorTextChange(${rowIndex}); convert();">
        <div class="error-message error-color" style="display: none;"></div>
      </div>
      <div>
        <input type="text" class="subexpression-occurrence" placeholder="1,3" value="${occurrenceValue}" 
               onchange="updateSubExpressionStyle(${rowIndex})" 
               oninput="updateSubExpressionStyle(${rowIndex}); convert();">
        <div class="error-message error-occurrence" style="display: none;"></div>
      </div>
      <button onclick="removeSubExpressionRow(${rowIndex})">âˆ’</button>
    `;

    rowsContainer.appendChild(row);
    
    // Initialize the style in the array
    if (!style) {
      subExpressionStyles.push({
        tex: '',
        color: colorValue,
        occurrence: ''
      });
    } else {
      subExpressionStyles.push(style);
    }

    // Sync color picker
    syncSubExpressionColorInputs(rowIndex);
  }

  function removeSubExpressionRow(rowIndex) {
    const row = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (row) {
      row.remove();
      // Remove from array at the correct index
      if (rowIndex >= 0 && rowIndex < subExpressionStyles.length) {
        subExpressionStyles.splice(rowIndex, 1);
      }
      // Re-index rows
      reindexSubExpressionRows();
      convert();
    }
  }

  function reindexSubExpressionRows() {
    const rows = Array.from(document.querySelectorAll('.subexpression-row'));
    // Rebuild subExpressionStyles array to match current rows
    const newStyles = [];
    rows.forEach((row, newIndex) => {
      const oldIndex = parseInt(row.getAttribute('data-row-index'));
      row.setAttribute('data-row-index', newIndex);
      
      // Get current values from the row
      const texInput = row.querySelector('.subexpression-tex');
      const colorInput = row.querySelector('.subexpression-color');
      const occurrenceInput = row.querySelector('.subexpression-occurrence');
      
      if (oldIndex >= 0 && oldIndex < subExpressionStyles.length) {
        // Preserve the style data, but update with current input values
        newStyles.push({
          tex: texInput ? texInput.value.trim() : (subExpressionStyles[oldIndex].tex || ''),
          color: colorInput ? colorInput.value.trim() : (subExpressionStyles[oldIndex].color || '808080'),
          occurrence: occurrenceInput ? occurrenceInput.value.trim() : (subExpressionStyles[oldIndex].occurrence || '')
        });
      } else {
        // New row, get values from inputs
        newStyles.push({
          tex: texInput ? texInput.value.trim() : '',
          color: colorInput ? colorInput.value.trim() : '808080',
          occurrence: occurrenceInput ? occurrenceInput.value.trim() : ''
        });
      }
      
      // Update event handlers
      if (texInput) {
        texInput.setAttribute('onchange', `updateSubExpressionStyle(${newIndex})`);
        texInput.setAttribute('oninput', `updateSubExpressionStyle(${newIndex}); convert();`);
      }
      if (row.querySelector('.subexpression-color-picker')) {
        row.querySelector('.subexpression-color-picker').setAttribute('onchange', `onSubExpressionColorChange(${newIndex})`);
      }
      if (row.querySelector('.subexpression-color')) {
        row.querySelector('.subexpression-color').setAttribute('onchange', `onSubExpressionColorTextChange(${newIndex})`);
        row.querySelector('.subexpression-color').setAttribute('oninput', `onSubExpressionColorTextChange(${newIndex}); convert();`);
      }
      if (row.querySelector('.subexpression-occurrence')) {
        row.querySelector('.subexpression-occurrence').setAttribute('onchange', `updateSubExpressionStyle(${newIndex})`);
        row.querySelector('.subexpression-occurrence').setAttribute('oninput', `updateSubExpressionStyle(${newIndex}); convert();`);
      }
      if (row.querySelector('button')) {
        row.querySelector('button').setAttribute('onclick', `removeSubExpressionRow(${newIndex})`);
      }
    });
    subExpressionStyles = newStyles;
  }

  function updateSubExpressionStyle(rowIndex) {
    const row = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (!row) return;

    const texInput = row.querySelector('.subexpression-tex');
    const colorInput = row.querySelector('.subexpression-color');
    const occurrenceInput = row.querySelector('.subexpression-occurrence');

    if (!texInput || !colorInput || !occurrenceInput) return;

    // Ensure array has entry at this index
    if (!subExpressionStyles[rowIndex]) {
      subExpressionStyles[rowIndex] = { tex: '', color: '808080', occurrence: '' };
    }

    subExpressionStyles[rowIndex].tex = texInput.value.trim();
    subExpressionStyles[rowIndex].color = colorInput.value.trim();
    subExpressionStyles[rowIndex].occurrence = occurrenceInput.value.trim();
  }

  function onSubExpressionColorChange(rowIndex) {
    const row = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (!row) return;

    const picker = row.querySelector('.subexpression-color-picker');
    const text = row.querySelector('.subexpression-color');
    const expanded = expandColor(picker.value);
    text.value = expanded;
    updateSubExpressionStyle(rowIndex);
    convert();
  }

  function onSubExpressionColorTextChange(rowIndex) {
    const row = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (!row) return;

    const picker = row.querySelector('.subexpression-color-picker');
    const text = row.querySelector('.subexpression-color');
    let value = text.value.trim();
    
    const expanded = expandColor(value);
    
    if (/^[0-9A-Fa-f]{1,6}$/i.test(value)) {
      text.value = expanded.substring(0, 6);
      picker.value = '#' + expanded.substring(0, 6);
      updateSubExpressionStyle(rowIndex);
    }
  }

  function syncSubExpressionColorInputs(rowIndex) {
    const row = document.querySelector(`[data-row-index="${rowIndex}"]`);
    if (!row) return;

    const picker = row.querySelector('.subexpression-color-picker');
    const text = row.querySelector('.subexpression-color');
    const currentValue = text.value.trim() || '808080';
    const expanded = expandColor(currentValue);
    text.value = expanded;
    picker.value = '#' + expanded;
  }

  function convert() {
    //  Get the TeX input
    var input = document.getElementById("input").value.trim();
    var bgcolorRaw = document.getElementById("bgcolor").value.trim() || THEME_DEFAULTS[currentTheme].background;
    var fontcolorRaw = document.getElementById("fontcolor").value.trim() || THEME_DEFAULTS[currentTheme].font;
    // Expand colors and add # prefix for CSS usage
    var bgcolor = '#' + expandColor(bgcolorRaw);
    var fontcolor = '#' + expandColor(fontcolorRaw);
    //  Disable the display button until MathJax is done
    var display = document.getElementById("display");
    display.disabled = true;
    //  Clear the old output
    output = document.getElementById('output');
    output.innerHTML = '';
    output.style.background = bgcolor;
    MathJax.texReset();
    var options = MathJax.getMetricsFor(output);
    options.display = display.checked;
    // Get font-size
    const fontsizeInput = document.getElementById('fontsize').value;
    const fontsize = fontsizeInput ? parseFloat(fontsizeInput) : 12;
    
    // Render without color command, then set color directly on SVG elements
    MathJax.tex2svgPromise(input, options).then(function (node) {
      // Set the color on all SVG elements after rendering
      setSVGColor(node, fontcolor);
      // Set font-size on the root SVG element (like vector library)
      node.setAttribute('font-size', fontsize + 'px');
      
      // Apply sub-expression colors
      applySubExpressionColors(node, subExpressionStyles);
      
      output.appendChild(node);
      MathJax.startup.document.clear();
      MathJax.startup.document.updateDocument();
      
      // Trigger real-time update if node is loaded and we're not just loading data
      if (!isLoadingNodeData) {
        debouncedUpdate();
      }
    }).catch(function (err) {
      output.appendChild(document.createElement('pre')).appendChild(document.createTextNode(err.message));
    }).then(function () {
      display.disabled = false;
    });
    
    // Save config after conversion
    saveConfig();
  }

  // Add input event listener for auto-render
  document.getElementById('input').addEventListener('input', convert);

  // Track if we have a node loaded that can be updated
  let hasNodeLoaded = false;
  let currentNodeId = null;
  
  // Flag to prevent updates when loading node data
  let isLoadingNodeData = false;
  
  // Debounce timer for real-time updates
  let updateTimer = null;

  // Draft state to preserve unplaced work
  let draftState = null;

  // Function to save current draft state
  function saveDraftState() {
    const styles = [];
    document.querySelectorAll('.subexpression-row').forEach((row) => {
      const texInput = row.querySelector('.subexpression-tex');
      const colorInput = row.querySelector('.subexpression-color');
      const occurrenceInput = row.querySelector('.subexpression-occurrence');
      if (texInput && colorInput && occurrenceInput) {
        styles.push({
          tex: texInput.value.trim(),
          color: colorInput.value.trim(),
          occurrence: occurrenceInput.value.trim()
        });
      }
    });

    draftState = {
      tex: document.getElementById("input").value.trim(),
      display: document.getElementById("display").checked,
      bgcolor: document.getElementById("bgcolor").value.trim(),
      fontcolor: document.getElementById("fontcolor").value.trim(),
      fontsize: document.getElementById("fontsize").value,
      subExpressionStyles: styles
    };
  }

  // Function to restore draft state
  function restoreDraftState() {
    if (draftState) {
      document.getElementById("input").value = draftState.tex;
      document.getElementById("display").checked = draftState.display;
      document.getElementById("bgcolor").value = draftState.bgcolor;
      document.getElementById("fontcolor").value = draftState.fontcolor;
      document.getElementById("fontsize").value = draftState.fontsize;
      
      // Update color pickers
      const bgcolorExpanded = expandColor(draftState.bgcolor);
      const fontcolorExpanded = expandColor(draftState.fontcolor);
      document.getElementById('bgcolor-picker').value = '#' + bgcolorExpanded;
      document.getElementById('fontcolor-picker').value = '#' + fontcolorExpanded;
      
      // Restore sub-expression styles
      if (draftState.subExpressionStyles) {
        // Clear existing rows
        document.getElementById('subexpression-rows').innerHTML = '';
        subExpressionStyles = [];
        subExpressionRowCounter = 0;
        
        // Add rows for each style
        draftState.subExpressionStyles.forEach(style => {
          addSubExpressionRow(style);
        });
      }
      
      // Re-render
      convert();
      
      draftState = null; // Clear after restoring
    }
  }

  // Function to switch to edit mode
  function switchToEditMode(nodeId) {
    // Save draft state before switching
    saveDraftState();
    
    hasNodeLoaded = true;
    currentNodeId = nodeId;
    
    // Show edit mode indicator
    const indicator = document.getElementById('edit-mode-indicator');
    indicator.classList.add('visible');
    document.getElementById('node-id-display').textContent = '#' + (nodeId ? nodeId.substring(0, 8) : '');
    
    // Hide preview in edit mode
    const previewContainer = document.getElementById('preview-container');
    previewContainer.classList.add('hidden');
    
    // Hide insert button
    const placeButton = document.getElementById('place');
    placeButton.classList.add('hidden');
  }

  // Function to switch to create mode
  function switchToCreateMode() {
    hasNodeLoaded = false;
    currentNodeId = null;
    
    // Hide edit mode indicator
    const indicator = document.getElementById('edit-mode-indicator');
    indicator.classList.remove('visible');
    
    // Show preview in create mode
    const previewContainer = document.getElementById('preview-container');
    previewContainer.classList.remove('hidden');
    
    // Show insert button
    const placeButton = document.getElementById('place');
    placeButton.classList.remove('hidden');
    
    // Restore draft state if available
    restoreDraftState();
  }

  // Helper function to prepare data for sending to backend
  // Handles all frontend concerns: color normalization, data extraction
  function prepareMessageData(updateExisting = false) {
    const svgElement = document.getElementById('output').firstChild;
    if (!svgElement) {
      return null; // No SVG rendered yet
    }
    
    const tex = document.getElementById("input").value.trim();
    const svg = svgElement.innerHTML;
    const fontsizeInput = document.getElementById('fontsize').value;
    const fontsize = fontsizeInput ? parseFloat(fontsizeInput) : 16;
    const bgcolorRaw = document.getElementById("bgcolor").value.trim() || THEME_DEFAULTS[currentTheme].background;
    const fontcolorRaw = document.getElementById("fontcolor").value.trim() || THEME_DEFAULTS[currentTheme].font;
    
    // Normalize colors: expand and add # prefix (backend expects normalized 6-digit hex with #)
    const bgcolor = '#' + expandColor(bgcolorRaw);
    const fontcolor = '#' + expandColor(fontcolorRaw);
    
    // Calculate scale from font-size (default MathJax font-size is 12px per em)
    const scale = fontsize / 12;
    
    // Collect sub-expression styles
    const styles = [];
    document.querySelectorAll('.subexpression-row').forEach((row) => {
      const texInput = row.querySelector('.subexpression-tex');
      const colorInput = row.querySelector('.subexpression-color');
      const occurrenceInput = row.querySelector('.subexpression-occurrence');
      if (texInput && colorInput && occurrenceInput) {
        styles.push({
          tex: texInput.value.trim(),
          color: colorInput.value.trim(),
          occurrence: occurrenceInput.value.trim()
        });
      }
    });
    
    return {
      tex,
      svg,
      scale,
      bgcolor,  // Normalized 6-digit hex with # prefix
      fontcolor, // Normalized 6-digit hex with # prefix
      fontsize,
      subExpressionStyles: styles,
      updateExisting
    };
  }

  // Function to send update to Figma (with debouncing)
  function sendUpdateToFigma() {
    if (!hasNodeLoaded) {
      return; // Don't update if no node is loaded
    }
    
    const data = prepareMessageData(true);
    if (!data) {
      return; // No SVG rendered yet
    }
    
    parent.postMessage({ pluginMessage: data }, '*');
  }

  // Debounced update function
  function debouncedUpdate() {
    if (updateTimer) {
      clearTimeout(updateTimer);
    }
    updateTimer = setTimeout(() => {
      sendUpdateToFigma();
    }, 300); // 300ms debounce delay
  }

  // place the svg on the figma canvas (for new nodes)
  document.getElementById('place').onclick = () => {
    const data = prepareMessageData(false);
    if (!data) {
      console.error('No SVG to embed');
      return;
    }
    parent.postMessage({ pluginMessage: data }, '*');
  }

  // Helper to sync color pickers and text inputs
  function syncColorInputs(colorId) {
    const picker = document.getElementById(colorId + '-picker');
    const text = document.getElementById(colorId);
    // When picker changes, update text (without #) and convert
    picker.addEventListener('input', () => {
      const expanded = expandColor(picker.value);
      text.value = expanded;
      convert(); // This will trigger debouncedUpdate via convert()
    });
    // When text changes, update picker (with #) and convert (handled by onColorTextChange)
    const currentValue = text.value.trim() || picker.value.replace(/^#/, '');
    const expanded = expandColor(currentValue);
    text.value = expanded;
    picker.value = '#' + expanded;
  }

  function onColorTextChange(colorId) {
    const picker = document.getElementById(colorId + '-picker');
    const text = document.getElementById(colorId);
    let value = text.value.trim();
    
    // Expand color according to convention
    const expanded = expandColor(value);
    
    // Validate: should be 1-6 hex digits
    if (/^[0-9A-Fa-f]{1,6}$/i.test(value)) {
      // Update text with expanded value (without #)
      text.value = expanded.substring(0, 6); // Limit to 6 hex digits for RGB
      // Add # to picker (color inputs need # prefix)
      picker.value = '#' + expanded.substring(0, 6);
      convert(); // This will trigger debouncedUpdate via convert()
    }
  }

  // Function to detect and apply OS theme
  function detectAndApplyOSTheme() {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const isDark = mediaQuery.matches;
    const theme = isDark ? 'dark' : 'light';
    
    // Update form inputs to match theme (CSS variables are handled by media query)
    applyTheme(theme);
    
    return theme;
  }

  // Locate button handler
  document.getElementById('locate-button').onclick = () => {
    parent.postMessage({ 
      pluginMessage: { 
        type: 'locateNode'
      } 
    }, '*');
  };

  // On load, detect OS theme and set fallback theme
  window.onload = () => {
    // Initialize to create mode
    switchToCreateMode();
    
    // Detect and apply OS theme
    const detectedTheme = detectAndApplyOSTheme();
    
    // Set color pickers to match text values (with #)
    const bgcolorValue = document.getElementById('bgcolor').value || THEME_DEFAULTS[currentTheme].background;
    const fontcolorValue = document.getElementById('fontcolor').value || THEME_DEFAULTS[currentTheme].font;
    const bgcolorExpanded = expandColor(bgcolorValue);
    const fontcolorExpanded = expandColor(fontcolorValue);
    document.getElementById('bgcolor-picker').value = '#' + bgcolorExpanded;
    document.getElementById('fontcolor-picker').value = '#' + fontcolorExpanded;
    document.getElementById('bgcolor').value = bgcolorExpanded;
    document.getElementById('fontcolor').value = fontcolorExpanded;
    syncColorInputs('bgcolor');
    syncColorInputs('fontcolor');
    convert();
  };

  window.addEventListener('message', event => {
    console.log('message', event);
    const message = event.data.pluginMessage || {};
    
    // Handle theme change
    if (message.theme === 'dark' || message.theme === 'light') {
      applyTheme(message.theme);
      // Update color pickers to match new theme (with #)
      const bgcolorValue = document.getElementById('bgcolor').value || THEME_DEFAULTS[message.theme].background;
      const fontcolorValue = document.getElementById('fontcolor').value || THEME_DEFAULTS[message.theme].font;
      const bgcolorExpanded = expandColor(bgcolorValue);
      const fontcolorExpanded = expandColor(fontcolorValue);
      document.getElementById('bgcolor-picker').value = '#' + bgcolorExpanded;
      document.getElementById('fontcolor-picker').value = '#' + fontcolorExpanded;
      document.getElementById('bgcolor').value = bgcolorExpanded;
      document.getElementById('fontcolor').value = fontcolorExpanded;
      convert(); // re-render with new colors
    }
    
    // Handle config load
    if (message.type === 'loadConfig' && message.config) {
      const config = message.config;
      if (config.display !== undefined) {
        document.getElementById('display').checked = config.display;
      }
      if (config.bgcolor) {
        // Expand color (config may have # prefix)
        const bgcolorValue = expandColor(config.bgcolor);
        document.getElementById('bgcolor').value = bgcolorValue;
        document.getElementById('bgcolor-picker').value = '#' + bgcolorValue;
      }
      if (config.fontcolor) {
        // Expand color (config may have # prefix)
        const fontcolorValue = expandColor(config.fontcolor);
        document.getElementById('fontcolor').value = fontcolorValue;
        document.getElementById('fontcolor-picker').value = '#' + fontcolorValue;
      }
      if (config.fontsize) {
        document.getElementById('fontsize').value = config.fontsize;
      }
      if (config.subExpressionStyles && Array.isArray(config.subExpressionStyles)) {
        // Clear existing rows
        document.getElementById('subexpression-rows').innerHTML = '';
        subExpressionStyles = [];
        subExpressionRowCounter = 0;
        
        // Add rows for each style
        config.subExpressionStyles.forEach(style => {
          addSubExpressionRow(style);
        });
      }
      convert(); // Apply loaded config
    }
    
    // Handle node data load (when selecting a node with plugin data)
    if (message.type === 'loadNodeData') {
      const { texSource, renderOptions, nodeId } = message;
      
      // Switch to edit mode
      switchToEditMode(nodeId);
      
      // Load TeX source
      if (texSource) {
        document.getElementById('input').value = texSource;
      }
      
      // Load render options
      if (renderOptions) {
        if (renderOptions.fontSize) {
          document.getElementById('fontsize').value = renderOptions.fontSize;
        }
        
        if (renderOptions.fontColor) {
          // Remove # prefix if present, then expand
          const fontcolorValue = expandColor(renderOptions.fontColor.replace(/^#/, ''));
          document.getElementById('fontcolor').value = fontcolorValue;
          document.getElementById('fontcolor-picker').value = '#' + fontcolorValue;
        }
        
        if (renderOptions.backgroundColor) {
          // Remove # prefix if present, then expand
          const bgcolorValue = expandColor(renderOptions.backgroundColor.replace(/^#/, ''));
          document.getElementById('bgcolor').value = bgcolorValue;
          document.getElementById('bgcolor-picker').value = '#' + bgcolorValue;
        }
        
        if (renderOptions.subExpressionStyles && Array.isArray(renderOptions.subExpressionStyles)) {
          // Clear existing rows
          document.getElementById('subexpression-rows').innerHTML = '';
          subExpressionStyles = [];
          subExpressionRowCounter = 0;
          
          // Add rows for each style
          renderOptions.subExpressionStyles.forEach(style => {
            addSubExpressionRow(style);
          });
        }
      }
      
      // Re-render with loaded data (but don't trigger update)
      isLoadingNodeData = true;
      convert();
      // Reset flag after a short delay to allow convert to complete
      setTimeout(() => {
        isLoadingNodeData = false;
      }, 100);
    }
    
    // Handle clearing node data (when no node with plugin data is selected)
    if (message.type === 'clearNodeData') {
      switchToCreateMode();
    }
  });
</script>